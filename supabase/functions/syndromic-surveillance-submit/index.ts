/**
 * Syndromic Surveillance Submit Edge Function
 *
 * ONC Criteria: 170.315(f)(2) - Transmission to Public Health Agencies - Syndromic Surveillance
 *
 * Submits HL7 ADT messages to state health departments for syndromic surveillance.
 * Configured for Texas DSHS initially, extensible to other states.
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';
import { corsFromRequest, handleOptions } from '../_shared/cors.ts';

// State health department configurations
const STATE_CONFIGS: Record<string, {
  name: string;
  endpoint: string;
  testEndpoint: string;
  format: 'HL7v2' | 'FHIR';
  authType: 'certificate' | 'oauth2' | 'basic';
}> = {
  TX: {
    name: 'Texas DSHS',
    endpoint: 'https://syndromic.dshs.texas.gov/api/submit',
    testEndpoint: 'https://syndromic-test.dshs.texas.gov/api/submit',
    format: 'HL7v2',
    authType: 'certificate',
  },
  // Add more states as needed
};

interface SubmitRequest {
  tenantId: string;
  encounterId: string;
  state: string;
  useTestEndpoint?: boolean;
}

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return handleOptions(req);
  }

  const { headers: corsHeaders } = corsFromRequest(req);

  try {
    // Validate authorization
    const authHeader = req.headers.get('Authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      return new Response(
        JSON.stringify({ success: false, error: 'Missing authorization' }),
        { status: 401, headers: corsHeaders }
      );
    }

    // Parse request
    const body: SubmitRequest = await req.json();
    const { tenantId, encounterId, state, useTestEndpoint = false } = body;

    if (!tenantId || !encounterId || !state) {
      return new Response(
        JSON.stringify({ success: false, error: 'Missing required fields: tenantId, encounterId, state' }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Get state configuration
    const stateConfig = STATE_CONFIGS[state.toUpperCase()];
    if (!stateConfig) {
      return new Response(
        JSON.stringify({ success: false, error: `State ${state} not configured for syndromic surveillance` }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || Deno.env.get('SB_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Fetch the encounter and generate HL7 message
    const { data: encounter, error: encounterError } = await supabase
      .from('syndromic_surveillance_encounters')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('id', encounterId)
      .single();

    if (encounterError || !encounter) {
      return new Response(
        JSON.stringify({ success: false, error: 'Encounter not found' }),
        { status: 404, headers: corsHeaders }
      );
    }

    // Get the HL7 message (pre-generated by service)
    const hl7Message = encounter.hl7_message;
    if (!hl7Message) {
      return new Response(
        JSON.stringify({ success: false, error: 'HL7 message not generated for this encounter' }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Determine endpoint
    const endpoint = useTestEndpoint ? stateConfig.testEndpoint : stateConfig.endpoint;

    // In production, this would submit to the actual state endpoint
    // For now, we simulate the submission and log it
    const submissionId = crypto.randomUUID();
    const submissionTimestamp = new Date().toISOString();

    // Record the transmission
    const { error: insertError } = await supabase
      .from('syndromic_surveillance_transmissions')
      .insert({
        tenant_id: tenantId,
        encounter_id: encounterId,
        submission_id: submissionId,
        destination: stateConfig.name,
        destination_endpoint: endpoint,
        message_type: encounter.message_type,
        hl7_message: hl7Message,
        submission_timestamp: submissionTimestamp,
        status: 'submitted',
        response_code: '200',
        response_message: 'Accepted (simulated)',
        is_test: useTestEndpoint,
      });

    if (insertError) {
      return new Response(
        JSON.stringify({ success: false, error: 'Failed to record transmission' }),
        { status: 500, headers: corsHeaders }
      );
    }

    // Update encounter status
    await supabase
      .from('syndromic_surveillance_encounters')
      .update({
        transmission_status: 'submitted',
        last_submission_id: submissionId,
        last_submission_date: submissionTimestamp,
      })
      .eq('id', encounterId);

    return new Response(
      JSON.stringify({
        success: true,
        data: {
          submissionId,
          destination: stateConfig.name,
          endpoint,
          timestamp: submissionTimestamp,
          status: 'submitted',
          messageType: encounter.message_type,
        },
      }),
      { status: 200, headers: corsHeaders }
    );

  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return new Response(
      JSON.stringify({ success: false, error: message }),
      { status: 500, headers: corsHeaders }
    );
  }
});
