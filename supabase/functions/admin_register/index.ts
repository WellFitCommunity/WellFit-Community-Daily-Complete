import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4?dts";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";

const SB_URL = Deno.env.get("SUPABASE_URL") || Deno.env.get("SB_URL") || "";
const SB_SECRET_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || Deno.env.get("SB_SECRET_KEY") || "";
const ADMIN_REGISTER_SECRET = Deno.env.get("ADMIN_REGISTER_SECRET") || "";

const corsHeaders = {
  "Content-Type": "application/json",
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-admin-register-secret",
};

const Payload = z.object({
  email: z.string().email().optional(),
  phone: z.string().min(10).optional(),
  password: z.string().min(8).optional(), // optional; can be autogenerated
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  role_code: z.number(), // any code allowed here (we enforce below)
  delivery: z.enum(["email", "sms", "none"]).default("none"),
});

type Input = z.infer<typeof Payload>;

const ELEVATED = new Set([1,2,3,12,14]);
const PUBLIC = new Set([4,5,6,11,13]);
const ALL = new Set([...ELEVATED, ...PUBLIC]);

function jsonResponse(body: unknown, status: number) {
  return new Response(JSON.stringify(body), { status, headers: corsHeaders });
}
function normalizePhone(phone?: string): string | undefined {
  if (!phone) return undefined;
  const digits = phone.replace(/\D/g, "");
  if (digits.length === 10) return `+1${digits}`;
  if (digits.length === 11 && digits.startsWith("1")) return `+${digits}`;
  return phone.startsWith("+") ? phone : `+${digits}`;
}

serve(async (req: Request) => {
  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: corsHeaders });
  if (req.method !== "POST") return jsonResponse({ error: "Method not allowed" }, 405);

  try {
    if (!SB_URL || !SB_SECRET_KEY) return jsonResponse({ error: "Server misconfigured" }, 500);

    // Gate: require either a valid admin session OR the secret header
    const supabase = createClient(SB_URL, SB_SECRET_KEY);
    const auth = req.headers.get("authorization");
    const bearer = auth?.toLowerCase().startsWith("bearer ") ? auth.split(" ")[1] : null;
    let isAdminSession = false;

    if (bearer) {
      // Look up caller's role via profiles (preferred) or user metadata
      const { data: userInfo } = await supabase.auth.getUser(bearer);
      const callerId = userInfo?.user?.id;
      if (callerId) {
        const { data: prof } = await supabase.from("profiles").select("role_code").eq("id", callerId).maybeSingle();
        if (prof?.role_code && ELEVATED.has(prof.role_code)) isAdminSession = true;
      }
    }
    const secretHeader = req.headers.get("x-admin-register-secret") || "";
    const hasSecret = ADMIN_REGISTER_SECRET && secretHeader === ADMIN_REGISTER_SECRET;

    if (!isAdminSession && !hasSecret) {
      return jsonResponse({ error: "Forbidden: admin credentials required" }, 403);
    }

    // Parse body
    let body: unknown;
    try { body = await req.json(); } catch { return jsonResponse({ error: "Invalid JSON" }, 400); }
    const parsed = Payload.safeParse(body);
    if (!parsed.success) return jsonResponse({ error: "Invalid data", details: parsed.error.errors }, 400);

    const input: Input = parsed.data;
    if (!ALL.has(input.role_code)) return jsonResponse({ error: "Invalid role_code" }, 400);

    const phone = normalizePhone(input.phone);
    const email = (input.email && input.email.trim() !== "") ? input.email : undefined;

    if (!email && !phone) return jsonResponse({ error: "Provide email or phone" }, 400);

    // Auto-gen password if missing
    const password = input.password ?? crypto.randomUUID() + "aA1!";

    const enforced = {
      role_code: input.role_code,
      role_slug: (() => {
        switch (input.role_code) {
          case 1: return "admin";
          case 2: return "super_admin";
          case 3: return "staff";
          case 4: return "senior";
          case 5: return "volunteer";
          case 6: return "caregiver";
          case 11: return "contractor";
          case 12: return "nurse_admin";
          case 13: return "regular";
          case 14: return "moderator";
          default: return "regular";
        }
      })(),
    };

    const { data: authData, error: authError } = await supabase.auth.admin.createUser({
      email,
      phone,
      password,
      email_confirm: !!email, // if you're inviting by email, you may set false to force a confirm flow
      phone_confirm: !!phone,
      user_metadata: {
        role_code: enforced.role_code,
        role_slug: enforced.role_slug,
        first_name: input.first_name,
        last_name: input.last_name,
        registration_method: "admin_manual",
        registered_at: new Date().toISOString(),
      },
    });

    if (authError) return jsonResponse({ error: "Failed to create user", details: authError.message }, 400);
    if (!authData?.user) return jsonResponse({ error: "User creation failed" }, 500);

    // Upsert profiles
    const profile = {
      id: authData.user.id,
      phone: phone ?? null,
      email: email ?? null,
      first_name: input.first_name,
      last_name: input.last_name,
      role_code: enforced.role_code,
      role_slug: enforced.role_slug,
      created_by: null, // (optional) fill from callerId if you want an audit trail
    };
    const { error: upErr } = await supabase.from("profiles").upsert(profile, { onConflict: "id" });
    if (upErr) console.error("[admin_register] profiles upsert error:", upErr.message);

    // Delivery (stub): you can wire MailerSend/Twilio here later.
    // For now, return the credentials decision so your admin UI can send externally if desired.
    return jsonResponse({
      success: true,
      user_id: authData.user.id,
      role_code: enforced.role_code,
      role_slug: enforced.role_slug,
      delivery: input.delivery,
      info: input.delivery === "none" ? "No credentials sent." : "Send credentials via your chosen channel.",
    }, 201);

  } catch (e: any) {
    console.error("[admin_register] unhandled:", e?.message || e);
    return jsonResponse({ error: "Internal server error", details: String(e?.message || e) }, 500);
  }
});
