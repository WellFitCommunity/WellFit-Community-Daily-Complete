import { SUPABASE_URL, SB_SECRET_KEY, SB_PUBLISHABLE_API_KEY } from "../_shared/env.ts";
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4?dts";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";
import { parsePhoneNumber, isValidPhoneNumber } from "https://esm.sh/libphonenumber-js@1.12.9?target=deno";
import { createLogger } from "../_shared/auditLogger.ts";

const logger = createLogger("admin_register");

// Allowed country codes for phone numbers
const ALLOWED_COUNTRIES = ['US', 'CA', 'GB', 'AU'] as const;

const SB_URL = SUPABASE_URL || Deno.env.get("SB_URL") || "";
const SERVICE_KEY = SB_SECRET_KEY || Deno.env.get("SB_SECRET_KEY") || "";
const ADMIN_REGISTER_SECRET = Deno.env.get("ADMIN_REGISTER_SECRET") || "";

const ALLOWED_ORIGINS = [
  "https://thewellfitcommunity.org",
  "https://wellfitcommunity.live",
  "http://localhost:3100",
  "https://localhost:3100"
];

function getCorsHeaders(origin: string | null) {
  const allowedOrigin = origin && ALLOWED_ORIGINS.includes(origin) ? origin : null;
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-admin-register-secret",
    "X-Content-Type-Options": "nosniff",
    "X-Frame-Options": "DENY",
    "X-XSS-Protection": "1; mode=block",
    "Referrer-Policy": "strict-origin-when-cross-origin",
    "Permissions-Policy": "camera=(), microphone=(), geolocation=()",
  };
  if (allowedOrigin) {
    headers["Access-Control-Allow-Origin"] = allowedOrigin;
  }
  return headers;
}

const Payload = z.object({
  email: z.string().email().optional(),
  phone: z.string().optional().refine(
    (phone) => {
      if (!phone) return true; // optional field
      try {
        if (!isValidPhoneNumber(phone, 'US')) return false;
        const phoneNumber = parsePhoneNumber(phone, 'US');
        const country = phoneNumber.country;
        return country !== undefined && (ALLOWED_COUNTRIES as readonly string[]).includes(country);
      } catch {
        return false;
      }
    },
    { message: "Invalid phone number format or unsupported country" }
  ),
  password: z.string().min(8).optional(), // optional; can be autogenerated
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  role_code: z.number(), // any code allowed here (we enforce below)
  delivery: z.enum(["email", "sms", "none"]).default("none"),
});

type Input = z.infer<typeof Payload>;

const ELEVATED = new Set([1,2,3,12,14]);
const PUBLIC = new Set([4,5,6,11,13]);
const ALL = new Set([...ELEVATED, ...PUBLIC]);

function jsonResponse(body: unknown, status: number, origin: string | null = null) {
  return new Response(JSON.stringify(body), { status, headers: getCorsHeaders(origin) });
}
/**
 * Normalize phone number to E.164 format using libphonenumber-js
 */
function normalizePhone(phone?: string): string | undefined {
  if (!phone) return undefined;
  try {
    const phoneNumber = parsePhoneNumber(phone, 'US');
    return phoneNumber.number; // Returns E.164 format: +15551234567
  } catch (error) {
    // Fallback to old logic if parsing fails
    const digits = phone.replace(/\D/g, "");
    if (digits.length === 10) return `+1${digits}`;
    if (digits.length === 11 && digits.startsWith("1")) return `+${digits}`;
    return phone.startsWith("+") ? phone : `+${digits}`;
  }
}

serve(async (req: Request) => {
  const origin = req.headers.get("origin");
  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: getCorsHeaders(origin) });
  if (req.method !== "POST") return jsonResponse({ error: "Method not allowed" }, 405, origin);

  try {
    if (!SB_URL || !SERVICE_KEY) return jsonResponse({ error: "Server misconfigured" }, 500, origin);

    // Gate: require either a valid admin session OR the secret header
    const supabase = createClient(SB_URL, SERVICE_KEY);
    const auth = req.headers.get("authorization");
    const bearer = auth?.toLowerCase().startsWith("bearer ") ? auth.split(" ")[1] : null;
    let isAdminSession = false;

    if (bearer) {
      // Look up caller's role via profiles (preferred) or user metadata
      const { data: userInfo } = await supabase.auth.getUser(bearer);
      const callerId = userInfo?.user?.id;
      if (callerId) {
        const { data: prof } = await supabase.from("profiles").select("role_code").eq("id", callerId).maybeSingle();
        if (prof?.role_code && ELEVATED.has(prof.role_code)) isAdminSession = true;
      }
    }
    const secretHeader = req.headers.get("x-admin-register-secret") || "";
    const hasSecret = ADMIN_REGISTER_SECRET && secretHeader === ADMIN_REGISTER_SECRET;

    if (!isAdminSession && !hasSecret) {
      return jsonResponse({ error: "Forbidden: admin credentials required" }, 403, origin);
    }

    // Parse body
    let body: unknown;
    try { body = await req.json(); } catch { return jsonResponse({ error: "Invalid JSON" }, 400, origin); }
    const parsed = Payload.safeParse(body);
    if (!parsed.success) return jsonResponse({ error: "Invalid data", details: parsed.error.errors }, 400, origin);

    const input: Input = parsed.data;
    if (!ALL.has(input.role_code)) return jsonResponse({ error: "Invalid role_code" }, 400, origin);

    const phone = normalizePhone(input.phone);
    const email = (input.email && input.email.trim() !== "") ? input.email : undefined;

    if (!email && !phone) return jsonResponse({ error: "Provide email or phone" }, 400, origin);

    // Auto-gen password if missing
    const password = input.password ?? crypto.randomUUID() + "aA1!";

    const enforced = {
      role_code: input.role_code,
      role_slug: (() => {
        switch (input.role_code) {
          case 1: return "admin";
          case 2: return "super_admin";
          case 3: return "staff";
          case 4: return "senior";
          case 5: return "volunteer";
          case 6: return "caregiver";
          case 11: return "contractor";
          case 12: return "nurse_admin";
          case 13: return "regular";
          case 14: return "moderator";
          default: return "regular";
        }
      })(),
    };

    const { data: authData, error: authError } = await supabase.auth.admin.createUser({
      email,
      phone,
      password,
      email_confirm: !!email, // if you're inviting by email, you may set false to force a confirm flow
      phone_confirm: !!phone,
      user_metadata: {
        role_code: enforced.role_code,
        role_slug: enforced.role_slug,
        first_name: input.first_name,
        last_name: input.last_name,
        registration_method: "admin_manual",
        registered_at: new Date().toISOString(),
      },
    });

    if (authError) return jsonResponse({ error: "Failed to create user", details: authError.message }, 400, origin);
    if (!authData?.user) return jsonResponse({ error: "User creation failed" }, 500, origin);

    // Upsert profiles
    const profile = {
      id: authData.user.id,
      phone: phone ?? null,
      email: email ?? null,
      first_name: input.first_name,
      last_name: input.last_name,
      role_code: enforced.role_code,
      role_slug: enforced.role_slug,
      created_by: null, // (optional) fill from callerId if you want an audit trail
    };
    const { error: upErr } = await supabase.from("profiles").upsert(profile, { onConflict: "id" });
    if (upErr) logger.error("profiles upsert error", { error: upErr.message, code: upErr.code });

    // Delivery (stub): you can wire MailerSend/Twilio here later.
    // For now, return the credentials decision so your admin UI can send externally if desired.
    return jsonResponse({
      success: true,
      user_id: authData.user.id,
      role_code: enforced.role_code,
      role_slug: enforced.role_slug,
      delivery: input.delivery,
      temporary_password: password, // Return password so admin can give it to patient
      info: input.delivery === "none" ? "No credentials sent." : "Send credentials via your chosen channel.",
    }, 201);

  } catch (err: unknown) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    logger.error("unhandled error", { error: errorMessage, stack: err instanceof Error ? err.stack : undefined });
    return jsonResponse({ error: "Internal server error", details: errorMessage }, 500, origin);
  }
});
